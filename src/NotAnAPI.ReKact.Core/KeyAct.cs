using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using NotAnAPI.ReKact.Core.Enums;

namespace NotAnAPI.ReKact.Core
{
    /// <summary>
    /// Class KeyAct.
    /// </summary>
    /// <autogeneratedoc />
    public class KeyAct
    {
        /// <summary>
        /// Gets or sets the index.
        /// </summary>
        /// <value>The index.</value>
        /// <autogeneratedoc />
        public int Index { get; set; }
        /// <summary>
        /// Gets or sets the type.
        /// </summary>
        /// <value>The type.</value>
        /// <autogeneratedoc />
        public ActTypes Type { get; set; }
        /// <summary>
        /// Gets or sets the time.
        /// </summary>
        /// <value>The time.</value>
        /// <autogeneratedoc />
        public int Time { get; set; }
        /// <summary>
        /// Gets or sets the KeyCode.
        /// </summary>
        /// <value>The KeyCode.</value>
        public int KeyCode { get; set; }
        /// <summary>
        /// Gets or sets the L.
        /// </summary>
        /// <value>The L.</value>
        public int L { get; set; }
        /// <summary>
        /// Gets or sets the Modifier.
        /// </summary>
        /// <value>The Modifier.</value>
        public int Modifier { get; set; }
        /// <summary>
        /// Gets or sets the FormElement.
        /// </summary>
        /// <value>The FormElement.</value>
        public int FormElement { get; set; }
        /// <summary>
        /// Gets or sets the NotTrusted.
        /// </summary>
        /// <value>The NotTrusted.</value>
        public int NotTrusted { get; set; } = -1;

        /// <summary>
        /// Gets a value indicating whether this <see cref="KeyAct"/> has SHIFT modifier.
        /// </summary>
        /// <value><c>true</c> if shift; otherwise, <c>false</c>.</value>
        public bool Shift { get; private set; }
        /// <summary>
        /// Gets a value indicating whether this <see cref="KeyAct"/> has CTRL modifier.
        /// </summary>
        /// <value><c>true</c> if control; otherwise, <c>false</c>.</value>
        public bool Ctrl { get; private set; }
        /// <summary>
        /// Gets a value indicating whether this <see cref="KeyAct"/> has META modifier.
        /// </summary>
        /// <value><c>true</c> if meta; otherwise, <c>false</c>.</value>
        public bool Meta { get; private set; }
        /// <summary>
        /// Gets a value indicating whether this <see cref="KeyAct"/> has ALT modifier.
        /// </summary>
        /// <value><c>true</c> if alt; otherwise, <c>false</c>.</value>
        public bool Alt { get; private set; }

        /// <summary>
        /// Gets or sets the charReKact.
        /// </summary>
        /// <value>The charReKact.</value>
        /// <autogeneratedoc />
        public string Char { get; set; }

        /// <summary>
        /// Gets a value indicating whether this instance is charReKact.
        /// </summary>
        /// <value><c>true</c> if this instance is charReKact; otherwise, <c>false</c>.</value>
        /// <autogeneratedoc />
        public bool IsCharReKact => IsDescribed == false && IsUnknown == false;

        /// <summary>
        /// Gets a value indicating whether the <seealso cref="Char"/> is not representing a charReKact.
        /// </summary>
        /// <value><c>true</c> if this instance is described; otherwise, <c>false</c>.</value>
        public bool IsDescribed => Char.StartsWith("[") && Char.Length >= 3;

        /// <summary>
        /// Gets a value indicating whether the keycode is unknown.
        /// </summary>
        /// <value><c>true</c> if this instance is unknown; otherwise, <c>false</c>.</value>
        public bool IsUnknown => Char.StartsWith("$") && Char.EndsWith("$") && Char.Length > 2;

        /// <summary>
        /// Gets the hash of this instance.<para />
        /// Hash calculated by <seealso cref="KeyCode"/>, <seealso cref="Char"/> and <seealso cref="NotTrusted"/>
        /// </summary>
        /// <value>The hash.</value>
        /// <autogeneratedoc />
        public long Hash
        {
            get
            {
                int hash = 13;
                hash = (hash * 7) + this.KeyCode.GetHashCode();
                hash = (hash * 7) + this.Char.GetHashCode();
                hash = (hash * 7) + this.NotTrusted.GetHashCode();
                return hash;
            }
        }


        /// <summary>
        /// Initializes a new instance of the <see cref="KeyAct"/> class.
        /// </summary>
        /// <autogeneratedoc />
        public KeyAct()
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="KeyAct"/> class.
        /// </summary>
        /// <param name="keyAct">The key act split by <c>,</c>.</param>
        /// <autogeneratedoc />
        public KeyAct(string[] keyAct)
        {
            ParseKeyAct(keyAct);
            Char = this.GetKeyByKeyCode();
        }

        /// <summary>
        /// Parses the key act.
        /// </summary>
        /// <param name="keyAct">The key act split by <c>,</c>.</param>
        /// <autogeneratedoc />
        private void ParseKeyAct(string[] keyAct)
        {
            this.Index = int.Parse(keyAct[(int) KactValues.Index]);
            this.Type = (ActTypes) int.Parse(keyAct[(int) KactValues.Type]);
            this.Time = int.Parse(keyAct[(int) KactValues.Time]);
            this.KeyCode = int.Parse(keyAct[(int) KactValues.KeyCode]);
            this.L = int.Parse(keyAct[(int) KactValues.L]);
            this.Modifier = int.Parse(keyAct[(int) KactValues.Modifier]);
            this.FormElement = int.Parse(keyAct[(int) KactValues.FormElement]);
            this.NotTrusted = int.Parse(keyAct.Length > 7 ? keyAct[(int) KactValues.NotTrusted] : "-1");

            CalculateModifiers();
        }

        /// <summary>
        /// Calculates the modifiers of the <see cref="KeyAct"/>.
        /// </summary>
        private void CalculateModifiers()
        {
            if (Modifier > 0)
            {
                var modifier = Modifier;
                int shift = 8;
                int ctrl = 4;
                int meta = 2;
                int alt = 1;
                modifier -= shift;
                if (!(modifier >= 0))
                {
                    modifier += shift;
                    shift = 0;
                }

                modifier -= ctrl;
                if (!(modifier >= 0))
                {
                    modifier += ctrl;
                    ctrl = 0;
                }

                modifier -= meta;
                if (!(modifier >= 0))
                {
                    modifier += meta;
                    meta = 0;
                }

                modifier -= alt;
                if (!(modifier >= 0))
                {
                    modifier += alt;
                    alt = 0;
                }

                if (modifier != 0)
                {
                    Debug.Print("Handled modifiers but the value is not 0");
                }

                this.Shift = shift != 0;
                this.Ctrl = ctrl != 0;
                this.Meta = meta != 0;
                this.Alt = alt != 0;
            }
        }

        /// <summary>
        /// Gets a value indicating whether this instance is submission.
        /// </summary>
        /// <value><c>true</c> if this instance is submission; otherwise, <c>false</c>.</value>
        /// <autogeneratedoc />
        public bool IsSubmission => this.Type == ActTypes.KeyDown && (this.KeyCode is 13 or 9);

#nullable enable
        /// <summary>
        /// Determines whether the specified <see cref="System.Object" /> is equal to this instance.
        /// </summary>
        /// <param name="y">The <see cref="System.Object" /> to compare with this instance.</param>
        /// <returns><c>true</c> if the specified <see cref="System.Object" /> is equal to this instance; otherwise, <c>false</c>.</returns>
        /// <autogeneratedoc />
        public override bool Equals(object? y)
        {
            if (y is not KeyAct yAsKeyAct) return false;
            return this.Index.Equals(yAsKeyAct.Index) && this.Type.Equals(yAsKeyAct.Type) &&
                   this.Time.Equals(yAsKeyAct.Time) &&
                   this.KeyCode.Equals(yAsKeyAct.KeyCode) && this.Modifier.Equals(yAsKeyAct.Modifier) &&
                   this.FormElement.Equals(yAsKeyAct.FormElement) &&
                   this.NotTrusted.Equals(yAsKeyAct.NotTrusted);
        }
#nullable disable

        /// <summary>
        /// Returns a hash code for this instance.
        /// </summary>
        /// <returns>A hash code for this instance, suitable for use in hashing algorithms and data structures like a hash table.</returns>
        /// <autogeneratedoc />
        [SuppressMessage("ReSharper", "NonReadonlyMemberInGetHashCode")]
        public override int GetHashCode()
        {
            int hash = 13;
            hash = (hash * 7) + this.Index.GetHashCode();
            hash = (hash * 7) + this.Type.GetHashCode();
            hash = (hash * 7) + this.KeyCode.GetHashCode();
            hash = (hash * 7) + this.Modifier.GetHashCode();
            hash = (hash * 7) + this.FormElement.GetHashCode();
            hash = (hash * 7) + this.NotTrusted.GetHashCode();
            return hash;
        }
    }
}